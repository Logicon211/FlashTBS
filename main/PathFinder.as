//A* pathfinding class for ActionScript 3.0//by Joe Hocking www.newarteest.com//adapted from http://www.policyalmanac.org/games/aStarTutorial.htm//use through PathFinder.go, not constructor//can be optimized/adjusted further, details below//incidentally, level as 2D array (0 walkable, 1 obstacle)package main  {	import Map.MapTile;		import Units.Unit;		import flash.geom.Point;	import flash.utils.Dictionary;
		public class PathFinder {		private var finTile:MapTile		private var level:Array;		private var openList:Dictionary;		private var closedList:Dictionary;		public var path:Array;		private var unit:Unit;			//returns an array of points in the path; if it's imposssible to find a path, return empty 		public static function go(fromTile:MapTile, toTile:MapTile, lvlData:Array, unitIn:Unit):Array {			var finder:PathFinder = new PathFinder(fromTile, toTile, lvlData, unitIn);			return finder.path;		}			//Constructor		public function PathFinder(fromTile:MapTile, toTile:MapTile, lvlData:Array, unitIn:Unit) {			finTile = toTile;			level = lvlData;			openList = new Dictionary(true);			closedList = new Dictionary(true);			path = new Array();			unit = unitIn;						//first node is the starting point			var node:MapTile = fromTile;			node.g = 0;			node.h = 0;			openList[fromTile.xCord + " " + fromTile.yCord] = node;						this.SearchLevel();		}			//the pathfinding algorithm		private function SearchLevel():void {			var curNode:MapTile;			var lowF = 100000;			var finished:Boolean = false;						//first determine node with lowest F			for each (var node in openList) {				var curF = node.g + node.h;								//currently this is just a brute force loop through every item in the list				//can be sped up using a sorted list or binary heap, described http://www.policyalmanac.org/games/binaryHeaps.htm				//example http://www.gotoandplay.it/_articles/2005/04/mazeChaser.php				if (lowF > curF) {					lowF = curF;					curNode = node;				}			}						//no path exists!			if (curNode == null) {return;}						//move selected node from open to closed list			delete openList[curNode.xCord + " " + curNode.yCord];			closedList[curNode.xCord + " " + curNode.yCord] = curNode;						//check target			if (curNode.xCord == finTile.xCord && curNode.yCord == finTile.yCord) {				var endNode:MapTile = curNode;				finished = true;			}						//check each of the 4 adjacent squares			for (var j = 0; j < 4; j++) {				var col;				var row;				if(j == 0)				{					col = curNode.xCord + 1; //eastTile					row = curNode.yCord;				}				else if(j == 1)				{					col = curNode.xCord + -1; //westTile					row = curNode.yCord;				}				else if(j == 2)				{					col = curNode.xCord;	 //northTile					row = curNode.yCord + 1;				}				else if(j == 3)				{					col = curNode.xCord;	//southTile					row = curNode.yCord - 1;				}									//make sure on the grid and not current node				if ((col >= 0 && col < level[0].length) && (row >= 0 && row < level.length) && (col != curNode.x || row != curNode.y) && curNode.canMove) {										//if walkable, not on closed list, and not already on open list - add to open list                  --ADDED BY ME, ^^ is to check if the current node is marked for movement					//adjust to no cutting corners, described http://www.policyalmanac.org/games/aStarTutorial.htm "Continuing the Search"					//example http://www.gotoandplay.it/_articles/2005/04/mazeChaser.php					//check G to open nodes, also described http://www.policyalmanac.org/games/aStarTutorial.htm "Continuing the Search"					if (level[row][col].getCost(unit) < 999 && closedList[col + " " + row] == null && openList[col + " " + row] == null) {												//determine g						var g = level[row][col].getCost(unit);												//calculate h						var h = (Math.abs(col - finTile.xCord)) + (Math.abs(row - finTile.yCord));												//create node						var found:MapTile = level[row][col];						found.g = g;						found.h = h;						found.parentTile = curNode;						openList[col + " " + row] = found;					}				}			}						//recurse if target not reached			if (finished == false) {				this.SearchLevel();			} else {				this.RetracePath(endNode);			}	}			//construct an array of points by retracing searched nodes		private function RetracePath(node:MapTile):void {			var step:MapTile = node			path.push(step);						if (node.g > 0) {				this.RetracePath(node.parentTile);			}		}		//end of class	}}